{
  "name": "mongraph",
  "description": "Mongraph combines documentstorage-database with graph-database relationships",
  "version": "0.1.17",
  "author": {
    "name": "Philipp Staender",
    "email": "philipp.staender@gmail.com"
  },
  "homepage": "https://github.com/pstaender/mongraph/",
  "main": "./lib/mongraph",
  "repository": {
    "type": "git",
    "url": "git://github.com:pstaender/mongraph.git"
  },
  "keywords": [
    "mongodb",
    "neo4j",
    "mongoose",
    "graphdatabase"
  ],
  "scripts": {
    "test": "./node_modules/coffee-script/bin/coffee --map -cb test src && mocha; npm run clean",
    "clean": "find src test -name '*.js' -delete -o -name '*.map' -delete",
    "build": "npm run clean && coffee --map -cbo lib src",
    "example": "coffee -cbo lib src && node examples/example.js",
    "documentation": "docco ./src/*.coffee",
    "doc": "groc ./src/*.coffee README.md",
    "benchmark": "coffee benchmark/benchmark.coffee",
    "prepare": "npm run test && npm run build && npm run documentation && npm run doc"
  },
  "devDependencies": {
    "mocha": "~1.9",
    "expect.js": "~0.2",
    "should": "~1.2",
    "mongoose": "~3.6",
    "neo4j": "~0.2",
    "docco": "~0.6",
    "groc": "~0.4",
    "source-map-support": "~0.1.2",
    "coveralls": "latest",
    "mongoskin": "latest",
    "benchmark": "~1.0",
    "microtime": "*",
    "futures": "~2.3.1",
    "request": "~2.21.0",
    "coffee-script": "~1.6.3"
  },
  "dependencies": {
    "underscore.string": "~2.3",
    "underscore": "~1.4",
    "join": "~2.3",
    "bson": "~0.1.8"
  },
  "licenses": {
    "type": "GPL"
  },
  "readme": "Mongraph [mɔ̃ ˈɡrɑːf]\n========\n\n[![Build Status](https://api.travis-ci.org/pstaender/mongraph.png)](https://travis-ci.org/pstaender/mongraph)\n\nMongraph combines documentstorage database with graph-database relationships by creating a corresponding node for each document.\n\n**Experimental. API may change.**\n**Currently it's only tested against Neo4j v1.8 and Neo4j v2 M3**\n\n### Installation\n\n```sh\n  $ npm install mongraph\n```\n\nor clone the repository to your project and install dependencies with npm:\n\n```sh\n  $ git clone git@github.com:pstaender/mongraph.git\n  $ cd mongraph && npm install\n```\n\n### What's it good for?\n\nMongoDB is great for a lot of things but a bit weak at relationships. However Neo4j is very powerful at this point but not the best solution for document storage. So why not using the best of both worlds?\n\n### What does it take?\n\nEvery document which is created in MongoDB will have a corresponding node in Neo4j:\n\n```\n             [{ _id: 5169…2, _node_id: 1 }]                  -> document in MongoDB\n                           / \\\n                            |\n                            |\n                           \\ /\n  ({ id: 1, data: { _id: 5169…2, _collection: 'people'} })   -> node in Neo4j\n```\n\nEach document has an extra attribute:\n\n  * `_node_id` (id of the corresponding node)\n\nEach node has extra attributes:\n\n  * `_id` (id of the corresponding document)\n  * `_collection` (name of the collection of the corresponding document)\n\nEach relationship will store informations about the start- and end-point-document and it's collection:\n\n```\n  (node#a) - { _from: \"people:516…2\", _to: \"locations:516…3\" … } - (node#b)\n```\n\n### What can it do?\n\nTo access the corresponding node:\n\n```js\n  // We can work with relationship after the document is stored in MongoDB\n  document = new Document({ title: 'Document Title'});\n  document.save(function(err, savedDocument){\n    savedDocument.log(savedDocument._node_id); // prints the id of the corresponding node\n    savedDocument.getNode(function(err, correspondingNode){\n      console.log(correspondingNode); // prints the node\n    });\n  });\n```\n\nTo access the corresponding document:\n\n```js\n  console.log(node.data._id); // prints the id of the corresponding document\n  console.log(node.data._collection); // prints the collection name of the corresponding \n  node.getDocument(function(err, correspondingDocument){\n    console.log(correspondingDocument); // prints the document\n  });\n```\n\nYou can create relationships between documents like you can do in Neo4j with nodes:\n\n```js\n  // create an outgoing relationship to another document\n  // please remember that we have to work here always with callbacks...\n  // that's why we are having the streamline placeholder here `_` (better to read)\n  document.createRelationshipTo(\n    otherDocument, 'similar', { category: 'article' }, _\n  );\n  // create an incoming relationship from another document\n  document.createRelationshipFrom(\n    otherDocument, 'similar', { category: 'article' }, _\n  );\n  // create a relationship between documents (bidirectional)\n  document.createRelationshipBetween(\n    otherDocument, 'similar', { category: 'article'},  _\n  );\n```\n\nYou can get and remove relationships from documents like you can do in Neo4j:\n\n```js\n  // get all documents which are pointing via 'view'\n  document.incomingRelationships('view', _);\n  // get all documents that are connected with 'view' (bidirectional)\n  document.allRelationships('view', _);\n  // same between documents\n  document.allRelationshipsBetween(otherDocument, 'view', _);\n  document.incomingRelationshipsFrom(otherDocument, 'view', _);\n  document.outgoingRelationshipsTo(otherDocument, 'view', _);\n```\n\nYou can filter the documents (mongodb) **and** the relationships (neo4j):\n\n```js\n  // get all similar documents where title starts with an uppercase\n  // and that are connected with the attribute `scientific report`\n  document.incomingRelationships(\n    'similar',\n    {\n      where: {\n        document: {\n          // we can query with the familiar mongodb query\n          title: /^[A-Z]/\n        },\n        // queries on graph are strings, because they are passed trough the cypher query directly for now\n        // here: relationship objects are accessible as `r` by default, start node as `a` and end node (if is queried) as `b` \n        relationship: \"r.category! = 'scientific report'\"\n      }\n    }, _\n  );\n```\n\nYou can also make your custom graph queries:\n\n```js\n  document.queryGraph(\n    \"START a = node(1), b = node(2) MATCH path = shortestPath( a-[*..5]->b ) RETURN path;\", \n    { processPart: 'path' },\n    function(err, path, options) { … }\n  );\n```\n\nTo get more informations about made queries (and finally used options) inspect the passed through options argument (`debug: true` enables logging of queries):\n\n```js\n  document.incomingRelationships(\n    'similar', { debug: true }, function(err, found, options) {\n      // prints out finally used options and - if set to `true` - additional debug informations\n      console.log(options.debug);\n      // { cypher: [ \"START … MATCH …\" , …] … }}\n    }\n  );\n```\n\n### Store in mongodb and neo4j simultaneously\n\nSince v0.1.15 you can store defined properties from mongodb documents in the corresponding nodes in neo4j. It might be a matter of opinion whether it's a good idea to store data redundant in two database system, anyway mongraph provides a tool to automate this process.\n\nYou need to provide the requested fields in your mongoose schemas with a `graph = true` option. Please note: If the property includes the `index = true` option (used in mongoose to index property in mongodb) this field will be also indexed in the graphdatabase.\n\nSince neo4j nodes store only non nested objects, your object will be flatten; e.g.:\n\n```js\n\n  data = {\n    property: {\n      subproperty: true\n    }\n  };\n  // will become\n  // data['property.subproperty'] = true\n```\n\n```js\nmessageSchema = new mongoose.Schema({\n  text: {\n    title: {\n      type: String,\n      graph: true // field / value will be stored in neo4j\n      index: true, // will be an indexed in neo4j as well\n    },\n    content: String\n  },\n  from: {\n    type: String,\n    graph: true  // field / value will be stored in neo4j, but not be indexed\n  }\n});\n``` \n\n### Your documents + nodes on neo4j\n\nBy default all corresponding nodes are created indexed with the collection-name and the _id, so that you can easily access them through neo4j, e.g.:\n\n```\n  http://localhost:7474/db/data/index/node/people/_id/5178fc1f6955993a25004711\n``` \n\n### Requirements\n\n#### Databases:\n\n  * MongoDB (~2)\n  * Neo4j (1.8)\n\n#### NPM modules:\n\n  * mongoose ORM <https://github.com/learnboost/mongoose> `npm install mongoose`\n  * Neo4j REST API client by thingdom <https://github.com/thingdom/node-neo4j> `npm install neo4j`\n\n### Examples and Tests\n\nYou'll find examples in `test/tests.coffee` and `examples/`.\n\n### Benchmarks\n\n`npm run benchmark` should output s.th. like:\n\n```\n### CREATING RECORDS\n\n* creating native mongodb documents x 964 ops/sec ±3.23% (68 runs sampled)\n* creating mongoose documents x 521 ops/sec ±1.25% (81 runs sampled)\n* creating neo4j nodes x 302 ops/sec ±13.87% (68 runs sampled)\n* creating mongraph documents x 132 ops/sec ±9.01% (68 runs sampled)\n\n**Fastest** is creating native mongodb documents\n\n**Slowest** is creating mongraph documents\n\n\n### FINDING RECORDS\n\n* selecting node x 279 ops/sec ±1.40% (84 runs sampled)\n* selecting native document x 627 ops/sec ±0.98% (80 runs sampled)\n* selecting mongoosse document x 574 ops/sec ±1.30% (78 runs sampled)\n* selecting document with corresponding node x 295 ops/sec ±9.45% (63 runs sampled)\n\n**Fastest** is selecting native document\n\n**Slowest** is selecting document with corresponding node\n```\n\n### Changelogs\n\n#### 0.1.14\n\n* **API Change:** the collection of the corresponding document will be stored from now on as `_collection` instead of `collection` in each node. e.g.: `node -> { data: { _id: 5ef6…, _collection: 'people' } }`, reason: continious name conventions in node-, document-, relationship- + path objects\n\n### License\n\nMongraph combines documentstorage-database with graph-database relationships\nCopyright (C) 2013 Philipp Staender <philipp.staender@gmail.com>\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n### Known issues and upcoming features\n\n  * process tools should avoid loading all documents on specific mongodb queries -> more effective queries\n  * replace of neo4j module with a neo4j mapper to have a more mongoose-like experience throughout\n  * using document `_id` as primary key in neo4j as well (in other words, drop support for `node_id` / `id`)\n  * using labels-feature for nodes (neo4j 2.0+) instead of `_collection` property\n  * dump and restore of relationships\n  * current release is only tested on neo4j 1.8, other version might have problems (please run tests to be sure); since the next release will only support neo4j 2.0+ I can't make any effort to support minor versions\n  * real-life benchmarks\n  * Currently mongraph **is not fully working with Neo4j v1.9**, but works with Neo4j v1.8 and 2.0 (M3)",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/pstaender/mongraph/issues"
  },
  "_id": "mongraph@0.1.17",
  "_from": "mongraph@latest"
}
